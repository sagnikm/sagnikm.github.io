<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sequential model | Sagnik Mukhopadhyay</title>
    <link>https://sagnikm.github.io/tag/sequential-model/</link>
      <atom:link href="https://sagnikm.github.io/tag/sequential-model/index.xml" rel="self" type="application/rss+xml" />
    <description>Sequential model</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 01 Jan 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://sagnikm.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Sequential model</title>
      <link>https://sagnikm.github.io/tag/sequential-model/</link>
    </image>
    
    <item>
      <title>Weighted Min-Cut: Sequential, Cut-Query and Streaming Algorithms</title>
      <link>https://sagnikm.github.io/publication/stoc2020/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://sagnikm.github.io/publication/stoc2020/</guid>
      <description>&lt;p&gt;Consider the following &lt;em&gt;2-respecting min-cut&lt;/em&gt; problem. Given a weighted graph $G$ and its spanning tree $T$, find the minimum cut among the cuts that contain at most two edges in $T$. This problem is an important subroutine in Karger&amp;rsquo;s celebrated randomized near-linear-time min-cut algorithm [STOC&#39;96]. We present a new approach for this problem which can be easily implemented in many settings, leading to the following randomized min-cut algorithms for weighted graphs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;An $O\left(m\frac{\log^2 n}{\log\log n} + n\log^6 n\right)$-time sequential algorithm: This improves Karger&amp;rsquo;s long-standing $O(m \log^3 n)$ and $O\left(m\frac{(\log^2 n)\log (n^2/m)}{\log\log n} + n\log^6 n\right)$ bounds when the input graph is not extremely sparse or dense. Improvements over Karger&amp;rsquo;s bounds were previously known only under a rather strong assumption that the input graph is {\em simple} (unweighted without parallel edges) [Henzinger, Rao, Wang, SODA&#39;17; Ghaffari, Nowicki, Thorup, SODA&#39;20]. For unweighted graphs  (possibly with parallel edges) and using bit operations, our bound can be further improved to $O\left(m\frac{\log^{1.5} n}{\log\log n} + n\log^6 n\right)$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An algorithm that requires $\tilde O(n)$ &lt;em&gt;cut queries&lt;/em&gt; to compute the min-cut of a weighted graph: This answers an open problem by Rubinstein, Schramm, and Weinberg [ITCS&#39;18], who obtained a similar bound for simple graphs. Our bound is tight up to polylogarithmic factors.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;streaming&lt;/em&gt; algorithm that requires $\tilde O(n)$ space and $O(\log n)$ passes to compute the min-cut: The only previous non-trivial exact min-cut algorithm in this setting is the 2-pass $\tilde O(n)$-space algorithm on simple graphs [Rubenstein et al. ITCS 2018] observed by Assadi, Chen, and Khanna [STOC&#39;19]).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In contrast to Karger&amp;rsquo;s 2-respecting min-cut algorithm which deploys sophisticated dynamic programming techniques, our approach exploits some cute structural properties so that it only needs to compute the values of $\tilde O(n)$ cuts corresponding to removing $\tilde O(n)$ pairs of tree edges, an operation that can be done quickly in many settings.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
